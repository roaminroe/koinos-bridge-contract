syntax = "proto3";

package bridge;

import "koinos/options.proto"; 

// Entrypoints

// @description Initialize contract
// @read-only false
message initialize_arguments {
  repeated bytes initial_validators = 1 [(koinos.btype) = ADDRESS];
}

message initialize_result {
}

// @description Pause/Unpause bridge
// @read-only false
message set_pause_arguments {
  repeated bytes signatures = 1;
  bool pause = 2;
}

message set_pause_result {
}

// @description Transfer tokens
// @read-only false
message transfer_tokens_arguments {
  bytes from = 1 [(koinos.btype) = ADDRESS];
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
  uint64 amount = 3;
  string recipient = 4;
}

message transfer_tokens_result {
}

// @description Complete a bridge transfer
// @read-only false
message complete_transfer_arguments {
  bytes transaction_id = 1 [(koinos.btype) = TRANSACTION_ID];
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
  bytes recipient = 3;
  uint64 value = 4;
  repeated bytes signatures = 6;
}

message complete_transfer_result {
}

// @description Add a new validator
// @read-only false
message add_validator_arguments {
  repeated bytes signatures = 1;
  bytes validator = 2 [(koinos.btype) = ADDRESS];
}

message add_validator_result {
}

// @description Remove an existing validator
// @read-only false
message remove_validator_arguments {
  repeated bytes signatures = 1;
  bytes validator = 2 [(koinos.btype) = ADDRESS];
}

message remove_validator_result {
}

// @description Add support for a new token
// @read-only false
message add_supported_token_arguments {
  repeated bytes signatures = 1;
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
}

message add_supported_token_result {
}

// @description Remove an existing supported token
// @read-only false
message remove_supported_token_arguments {
  repeated bytes signatures = 1;
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
}

message remove_supported_token_result {
}

// @description Add support for a new wrapped token
// @read-only false
message add_supported_wrapped_token_arguments {
  repeated bytes signatures = 1;
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
}

message add_supported_wrapped_token_result {
}

// @description Remove an existing supported token
// @read-only false
message remove_supported_wrapped_token_arguments {
  repeated bytes signatures = 1;
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
}

message remove_supported_wrapped_token_result {
}

// Events
message transfer_tokens_event {
  bytes from = 1 [(koinos.btype) = ADDRESS];
  bytes token = 2 [(koinos.btype) = CONTRACT_ID];
  uint64 amount = 3;
  string recipient = 4;
}

// Objects
message add_remove_action_hash {
  bytes address = 1;
  uint64 nonce = 2;
  bytes contract_id = 3;
}

message set_pause_action_hash {
  bool pause = 1;
  uint64 nonce = 2;
  bytes contract_id = 3;
}

message complete_transfer_hash {
  bytes transaction_id = 1;
  bytes token = 2;
  bytes recipient = 3;
  uint64 amount = 4;
  bytes contract_id = 5;
}

message metadata_object {
  bool initialized = 1; 
  uint64 nonce = 2;
  uint32 nb_validators = 3;
}

// use an object to possibly store metadata later on
message validator_object {
  
}

message wrapped_token_object {
  
}

message token_object {
  
}